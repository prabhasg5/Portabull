"""
Portabull - Portfolio Monitoring System
Real-time monitoring and anomaly detection

Features:
- Continuous portfolio monitoring
- Anomaly detection (price spikes, volume changes)
- Proactive alerts and discussions
- Pattern recognition
"""

import asyncio
from typing import Dict, Any, List, Optional, Callable
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from loguru import logger
import statistics


class AlertSeverity(Enum):
    """Alert severity levels"""
    INFO = "info"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class AlertType(Enum):
    """Types of monitoring alerts"""
    PRICE_SPIKE = "price_spike"
    PRICE_DROP = "price_drop"
    VOLUME_ANOMALY = "volume_anomaly"
    PORTFOLIO_DRAWDOWN = "portfolio_drawdown"
    SECTOR_ROTATION = "sector_rotation"
    CORRELATION_BREAKDOWN = "correlation_breakdown"
    NEWS_IMPACT = "news_impact"
    EARNINGS_ALERT = "earnings_alert"
    UNUSUAL_ACTIVITY = "unusual_activity"


@dataclass
class MonitoringAlert:
    """Alert generated by the monitoring system"""
    id: str
    alert_type: AlertType
    severity: AlertSeverity
    title: str
    description: str
    affected_symbols: List[str]
    metrics: Dict[str, Any]
    recommended_action: str
    timestamp: datetime = field(default_factory=datetime.now)
    acknowledged: bool = False
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "type": self.alert_type.value,
            "severity": self.severity.value,
            "title": self.title,
            "description": self.description,
            "symbols": self.affected_symbols,
            "metrics": self.metrics,
            "action": self.recommended_action,
            "timestamp": self.timestamp.isoformat(),
            "acknowledged": self.acknowledged
        }


@dataclass
class SymbolMetrics:
    """Metrics tracked for each symbol"""
    symbol: str
    prices: List[float] = field(default_factory=list)
    volumes: List[int] = field(default_factory=list)
    timestamps: List[datetime] = field(default_factory=list)
    avg_price: float = 0.0
    avg_volume: float = 0.0
    price_volatility: float = 0.0
    volume_volatility: float = 0.0
    
    def add_datapoint(self, price: float, volume: int):
        """Add a new data point"""
        self.prices.append(price)
        self.volumes.append(volume)
        self.timestamps.append(datetime.now())
        
        # Keep only last 100 data points
        if len(self.prices) > 100:
            self.prices = self.prices[-100:]
            self.volumes = self.volumes[-100:]
            self.timestamps = self.timestamps[-100:]
        
        # Update statistics
        self._update_stats()
    
    def _update_stats(self):
        """Update rolling statistics"""
        if len(self.prices) >= 2:
            self.avg_price = statistics.mean(self.prices)
            self.avg_volume = statistics.mean(self.volumes)
            self.price_volatility = statistics.stdev(self.prices) / self.avg_price if self.avg_price else 0
            self.volume_volatility = statistics.stdev(self.volumes) / self.avg_volume if self.avg_volume else 0


class AnomalyDetector:
    """
    Anomaly Detection Engine
    
    Detects unusual patterns in:
    - Price movements
    - Volume changes
    - Portfolio performance
    - Market correlations
    """
    
    def __init__(
        self,
        price_threshold: float = 5.0,  # % change
        volume_threshold: float = 3.0,  # Standard deviations
        drawdown_threshold: float = 5.0  # % drawdown
    ):
        self.price_threshold = price_threshold
        self.volume_threshold = volume_threshold
        self.drawdown_threshold = drawdown_threshold
        
        # Track metrics per symbol
        self.symbol_metrics: Dict[str, SymbolMetrics] = {}
        
        # Portfolio-level tracking
        self.portfolio_values: List[float] = []
        self.peak_value: float = 0.0
        
        logger.info("AnomalyDetector initialized")
    
    def update_symbol(
        self,
        symbol: str,
        price: float,
        volume: int,
        prev_price: float = None
    ) -> List[MonitoringAlert]:
        """
        Update symbol data and check for anomalies
        
        Returns list of alerts if anomalies detected
        """
        
        alerts = []
        
        # Initialize metrics if new symbol
        if symbol not in self.symbol_metrics:
            self.symbol_metrics[symbol] = SymbolMetrics(symbol=symbol)
        
        metrics = self.symbol_metrics[symbol]
        
        # Check for price anomaly before adding new data
        if prev_price and prev_price > 0:
            price_change = ((price - prev_price) / prev_price) * 100
            
            if abs(price_change) >= self.price_threshold:
                alert_type = AlertType.PRICE_SPIKE if price_change > 0 else AlertType.PRICE_DROP
                severity = self._get_price_severity(abs(price_change))
                
                alerts.append(MonitoringAlert(
                    id=f"{symbol}_{alert_type.value}_{datetime.now().timestamp()}",
                    alert_type=alert_type,
                    severity=severity,
                    title=f"{'ðŸ“ˆ' if price_change > 0 else 'ðŸ“‰'} {symbol} moved {price_change:+.2f}%",
                    description=f"{symbol} has moved significantly from â‚¹{prev_price:.2f} to â‚¹{price:.2f}",
                    affected_symbols=[symbol],
                    metrics={
                        "price_change_percent": price_change,
                        "previous_price": prev_price,
                        "current_price": price
                    },
                    recommended_action=self._get_price_action(price_change, symbol)
                ))
        
        # Check for volume anomaly
        if metrics.volumes and metrics.avg_volume > 0:
            volume_zscore = (volume - metrics.avg_volume) / (
                statistics.stdev(metrics.volumes) if len(metrics.volumes) > 1 else metrics.avg_volume
            )
            
            if abs(volume_zscore) >= self.volume_threshold:
                alerts.append(MonitoringAlert(
                    id=f"{symbol}_volume_{datetime.now().timestamp()}",
                    alert_type=AlertType.VOLUME_ANOMALY,
                    severity=AlertSeverity.MEDIUM,
                    title=f"ðŸ”Š Unusual volume in {symbol}",
                    description=f"Volume is {volume_zscore:.1f}x higher than average",
                    affected_symbols=[symbol],
                    metrics={
                        "current_volume": volume,
                        "avg_volume": metrics.avg_volume,
                        "volume_zscore": volume_zscore
                    },
                    recommended_action="Investigate potential news or market activity"
                ))
        
        # Add new data point
        metrics.add_datapoint(price, volume)
        
        return alerts
    
    def update_portfolio(
        self,
        total_value: float,
        holdings_data: List[Dict[str, Any]]
    ) -> List[MonitoringAlert]:
        """
        Update portfolio-level tracking and check for anomalies
        
        Returns list of portfolio-level alerts
        """
        
        alerts = []
        
        # Track portfolio value
        self.portfolio_values.append(total_value)
        if len(self.portfolio_values) > 100:
            self.portfolio_values = self.portfolio_values[-100:]
        
        # Update peak
        if total_value > self.peak_value:
            self.peak_value = total_value
        
        # Check for drawdown
        if self.peak_value > 0:
            drawdown = ((self.peak_value - total_value) / self.peak_value) * 100
            
            if drawdown >= self.drawdown_threshold:
                severity = self._get_drawdown_severity(drawdown)
                
                alerts.append(MonitoringAlert(
                    id=f"portfolio_drawdown_{datetime.now().timestamp()}",
                    alert_type=AlertType.PORTFOLIO_DRAWDOWN,
                    severity=severity,
                    title=f"âš ï¸ Portfolio drawdown: {drawdown:.2f}%",
                    description=f"Portfolio has fallen {drawdown:.2f}% from peak of â‚¹{self.peak_value:,.2f}",
                    affected_symbols=[h.get("tradingsymbol", "") for h in holdings_data],
                    metrics={
                        "current_value": total_value,
                        "peak_value": self.peak_value,
                        "drawdown_percent": drawdown
                    },
                    recommended_action="Review risk exposure and consider rebalancing"
                ))
        
        # Check for unusual sector concentration
        sector_alerts = self._check_sector_concentration(holdings_data)
        alerts.extend(sector_alerts)
        
        return alerts
    
    def _get_price_severity(self, change_percent: float) -> AlertSeverity:
        """Determine severity based on price change magnitude"""
        if change_percent >= 20:
            return AlertSeverity.CRITICAL
        elif change_percent >= 10:
            return AlertSeverity.HIGH
        elif change_percent >= 5:
            return AlertSeverity.MEDIUM
        else:
            return AlertSeverity.LOW
    
    def _get_drawdown_severity(self, drawdown: float) -> AlertSeverity:
        """Determine severity based on drawdown magnitude"""
        if drawdown >= 20:
            return AlertSeverity.CRITICAL
        elif drawdown >= 10:
            return AlertSeverity.HIGH
        elif drawdown >= 5:
            return AlertSeverity.MEDIUM
        else:
            return AlertSeverity.LOW
    
    def _get_price_action(self, change_percent: float, symbol: str) -> str:
        """Get recommended action based on price change"""
        if change_percent > 10:
            return f"Consider taking partial profits on {symbol}"
        elif change_percent < -10:
            return f"Review fundamentals of {symbol} - consider stop-loss"
        elif change_percent > 0:
            return f"Monitor {symbol} for continuation or reversal"
        else:
            return f"Watch for support levels in {symbol}"
    
    def _check_sector_concentration(
        self,
        holdings_data: List[Dict[str, Any]]
    ) -> List[MonitoringAlert]:
        """Check for dangerous sector concentration"""
        
        # This would use actual sector mapping in production
        # For hackathon, using simplified logic
        
        alerts = []
        
        total_value = sum(h.get("value", 0) for h in holdings_data)
        
        if total_value > 0:
            # Check if any single stock is > 30% of portfolio
            for holding in holdings_data:
                value = holding.get("value", 0)
                weight = (value / total_value) * 100
                
                if weight > 30:
                    alerts.append(MonitoringAlert(
                        id=f"concentration_{holding.get('tradingsymbol')}_{datetime.now().timestamp()}",
                        alert_type=AlertType.UNUSUAL_ACTIVITY,
                        severity=AlertSeverity.MEDIUM,
                        title=f"âš–ï¸ High concentration in {holding.get('tradingsymbol')}",
                        description=f"{holding.get('tradingsymbol')} represents {weight:.1f}% of your portfolio",
                        affected_symbols=[holding.get('tradingsymbol', '')],
                        metrics={"weight_percent": weight},
                        recommended_action="Consider diversifying to reduce concentration risk"
                    ))
        
        return alerts


class PortfolioMonitor:
    """
    Main Portfolio Monitoring Service
    
    Runs continuously to:
    - Monitor portfolio changes
    - Detect anomalies
    - Generate alerts
    - Trigger proactive discussions
    """
    
    def __init__(
        self,
        zerodha_client: Any,
        orchestrator: Any,
        on_alert: Callable[[MonitoringAlert], None] = None,
        check_interval: int = 30  # seconds
    ):
        self.zerodha_client = zerodha_client
        self.orchestrator = orchestrator
        self.on_alert = on_alert
        self.check_interval = check_interval
        
        self.anomaly_detector = AnomalyDetector()
        
        self.running = False
        self.alerts: List[MonitoringAlert] = []
        self.last_portfolio_data: Optional[Dict[str, Any]] = None
        
        logger.info("PortfolioMonitor initialized")
    
    async def start(self):
        """Start the monitoring loop"""
        self.running = True
        logger.info("Portfolio monitoring started")
        
        while self.running:
            try:
                await self._check_portfolio()
            except Exception as e:
                logger.error(f"Monitoring error: {e}")
            
            await asyncio.sleep(self.check_interval)
    
    async def stop(self):
        """Stop the monitoring loop"""
        self.running = False
        logger.info("Portfolio monitoring stopped")
    
    async def _check_portfolio(self):
        """Check portfolio for changes and anomalies"""
        
        # Get current portfolio
        portfolio_data = await self.zerodha_client.get_portfolio_summary()
        
        new_alerts = []
        
        # Check each holding
        for holding in portfolio_data.get("holdings", []):
            symbol = holding.get("tradingsymbol", "")
            current_price = holding.get("last_price", 0)
            
            # Get previous price
            prev_price = None
            if self.last_portfolio_data:
                prev_holdings = self.last_portfolio_data.get("holdings", [])
                prev_holding = next(
                    (h for h in prev_holdings if h.get("tradingsymbol") == symbol),
                    None
                )
                if prev_holding:
                    prev_price = prev_holding.get("last_price")
            
            # Check for anomalies
            symbol_alerts = self.anomaly_detector.update_symbol(
                symbol=symbol,
                price=current_price,
                volume=0,  # Volume would come from real-time feed
                prev_price=prev_price
            )
            new_alerts.extend(symbol_alerts)
        
        # Check portfolio-level
        total_value = portfolio_data.get("summary", {}).get("total_current_value", 0)
        portfolio_alerts = self.anomaly_detector.update_portfolio(
            total_value=total_value,
            holdings_data=portfolio_data.get("holdings", [])
        )
        new_alerts.extend(portfolio_alerts)
        
        # Process alerts
        for alert in new_alerts:
            self.alerts.append(alert)
            
            # Callback if registered
            if self.on_alert:
                self.on_alert(alert)
            
            # Trigger proactive discussion for high severity alerts
            if alert.severity in [AlertSeverity.HIGH, AlertSeverity.CRITICAL]:
                await self._trigger_discussion(alert, portfolio_data)
        
        # Update last portfolio data
        self.last_portfolio_data = portfolio_data
        
        if new_alerts:
            logger.info(f"Generated {len(new_alerts)} new alerts")
    
    async def _trigger_discussion(
        self,
        alert: MonitoringAlert,
        portfolio_data: Dict[str, Any]
    ):
        """Trigger a proactive discussion about an alert"""
        
        logger.info(f"Triggering discussion for alert: {alert.title}")
        
        # Use orchestrator to facilitate discussion
        if self.orchestrator:
            from agents.orchestrator import AlertEvent
            
            alert_event = AlertEvent(
                alert_type=alert.alert_type.value,
                severity=alert.severity.value,
                title=alert.title,
                description=alert.description,
                affected_symbols=alert.affected_symbols,
                recommended_action=alert.recommended_action
            )
            
            debate = await self.orchestrator.start_proactive_discussion(
                alert=alert_event,
                portfolio_data=portfolio_data
            )
            
            logger.info(f"Discussion completed: {debate.consensus}")
    
    def get_recent_alerts(self, limit: int = 10) -> List[MonitoringAlert]:
        """Get recent alerts"""
        return sorted(
            self.alerts,
            key=lambda a: a.timestamp,
            reverse=True
        )[:limit]
    
    def acknowledge_alert(self, alert_id: str):
        """Mark an alert as acknowledged"""
        for alert in self.alerts:
            if alert.id == alert_id:
                alert.acknowledged = True
                break
    
    def get_unacknowledged_alerts(self) -> List[MonitoringAlert]:
        """Get all unacknowledged alerts"""
        return [a for a in self.alerts if not a.acknowledged]
